// COPYRIGHT Â© 2018 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.9/esri/copyright.txt for details.

define(["require","exports"],function(e,n){return{background:{"background.frag":"uniform lowp vec4 u_color;\nvoid main() {\n  gl_FragColor = u_color;\n}\n","background.vert":"attribute vec2 a_pos;\n\nuniform highp mat4 u_transformMatrix;\nuniform mediump vec2 u_normalized_origin;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\nvoid main() {\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(u_coord_range * a_pos, 0.0, 1.0);\n}\n"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\n\nvarying mediump vec2 v_uv;\n\nvoid main() {\n  lowp vec4 color = texture2D(u_tex, v_uv);\n\n  // Note: output in pre-multiplied alpha for correct alpha compositing\n  gl_FragColor = color *  u_opacity;\n}\n","bitBlit.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\n\nvarying mediump vec2 v_uv;\n\nvoid main(void) {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n  v_uv = a_tex;\n}\n"},heatmap:{"heatmap.frag":"precision mediump float;\n\nuniform lowp sampler2D u_texture;\nuniform lowp float u_opacity;\nuniform mediump vec2 u_minmax;\nuniform lowp sampler2D u_gradient;\n\nvarying mediump vec2 v_uv;\nvarying mediump float v_slope;\n\nvec4 getColor(float intensity) {\n  float normalizedIntensity = clamp((intensity - u_minmax.x) * v_slope, 0.0, 1.0);\n\n  return texture2D(u_gradient, vec2(0.5, normalizedIntensity));\n}\n\nvoid main() {\n  // sample the intensity value\n  lowp vec4 color = texture2D(u_texture, v_uv);\n\n  // interpolate the color from the ramp using the intensity value\n  gl_FragColor = getColor(color.r) *  u_opacity;\n}\n","heatmap.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\n\nuniform mediump vec2 u_minmax;\n\nvarying mediump vec2 v_uv;\nvarying mediump float v_slope;\n\nvoid main(void) {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n  v_uv = a_tex;\n  v_slope = 1.0 / (u_minmax.y - u_minmax.x);\n}\n"},highlight:{"blur.frag":"// A gaussian blur shader. It blurs the alpha channel of its input\n// according to 4 different sigma and stores the results into the\n// four channel of the target framebuffer.\n\n// It is intended to be called twice; the first time to perform an\n// horizontal blur, and a second time to perform a vertical blur.\n\n// This shader is used to turn the highlight mask into a highlight\n// map. The highlight map is an approximation of the signed distance\n// field of the mask.\n\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// Blur direction information. There are two possible\n// configurations that the host code can use.\n//  - [1, 0, 1/WIDTH, 0] Used when blurring horizontally. In this\n//    case u_direction[0] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[2] = 1/WIDTH is in texel units\n//    and is used to sample the right texel from the texture map.\n//  - [0, 1, 0, 1/HEIGHT] Used when blurring vertically. In this\n//    case u_direction[1] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[3] = 1/HEIGHT is in texel units\n//    and is used to sample the right texel from the texture map.\nuniform mediump vec4 u_direction;\n\n// Source to destination channel selection matrix.\nuniform mediump mat4 u_channelSelector;\n\n// The highlight map is obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// This is the highlight mask if we have not blurred horizontally yet, otherwise\n// it is the horizontally blurred highlight map and blurring it one more time\n// vertically will complete the process.\nuniform sampler2D u_texture;\n\n// The gaussian kernel. Note that it lacks the normalization constant, because\n// we want to store it unnormalized in the highlight map (i.e. having a peak\n// value of 1). Note also that we are using the SIMD (single instruction, multiple\n// data) capabilities of the GPU to compute four different gaussian kernels, one\n// for each sigma.\nmediump vec4 gauss(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas * u_sigmas));\n}\n\nmediump vec4 selectChannel(mediump vec4 sample) {\n  return u_channelSelector * sample;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight.\nvoid accumGauss(mediump float i, inout mediump vec4 tot, inout mediump vec4 weight) {\n  // Computes the gaussian weights, one for each sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump vec4 w = gauss(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw)) * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\nvoid main(void) {\n  // Initialize accumulated values and weights to zero.\n  mediump vec4 tot = vec4(0.0, 0.0, 0.0, 0.0);\n  mediump vec4 weight = vec4(0.0, 0.0, 0.0, 0.0);\n\n  // Accumulates enough samples. These will be taken\n  // horizontally or vertically depending on the value\n  // of u_direction.\n  accumGauss(-5.0, tot, weight);\n  accumGauss(-4.0, tot, weight);\n  accumGauss(-3.0, tot, weight);\n  accumGauss(-2.0, tot, weight);\n  accumGauss(-1.0, tot, weight);\n  accumGauss(0.0, tot, weight);\n  accumGauss(1.0, tot, weight);\n  accumGauss(2.0, tot, weight);\n  accumGauss(3.0, tot, weight);\n  accumGauss(4.0, tot, weight);\n  accumGauss(5.0, tot, weight);\n\n  // Compute blurred values.\n  mediump vec4 rgba = tot / weight;\n\n  // Return the values. Note that each channel will contain\n  // the result of a different blur operation, one for each\n  // of the four chosen sigma.\n  gl_FragColor = vec4(rgba);\n}\n","highlight.frag":"// Takes as input the highlight map, estimated the signed distance field,\n// and shades the fragments according to their estimated distance from the\n// edge of the highlighted feature.\n\n// A shade texture is used to turn distance values into colors; the shade\n// texture is basically a color gradient and is recomputed on the host\n// every time that the user alters the highlight options.\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// The highlight map. Each channel is a blurred\n// version of the alpha channel of the highlight mask.\n//  - Channel 0 (red) corresponds to a gaussian blur with sigma = u_sigmas[0];\n//  - Channel 1 (green) corresponds to a gaussian blur with sigma = u_sigmas[1];\n//  - Channel 2 (blue) corresponds to a gaussian blur with sigma = u_sigmas[2];\n//  - Channel 3 (alpha) corresponds to a gaussian blur with sigma = u_sigmas[3];\n// As of today, only channel 3 is used for distance estimation.\n// But the availability of different amounts of blur leaves the\n// door open to multi-scale approaches.\nuniform sampler2D u_texture;\n\n// The highlight map was obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// A 1-D texture used to shade the highlight.\nuniform sampler2D u_shade;\n\n// The 1-D shade texture is spreaded between u_minMaxDistance[0] and u_minMaxDistance[1].\nuniform mediump vec2 u_minMaxDistance;\n\n// Signed distance estimation.\nmediump float estimateDistance() {\n  // Use the largest sigma and the corresponding distance value stored in the\n  // last channel of the highlight map.\n  mediump float sigma = u_sigmas[3];\n  mediump float y = texture2D(u_texture, v_texcoord)[3];\n\n  // Estimates the distance by linearization and local inversion around\n  // the inflection point. The inflection point is in x = 0.\n  const mediump float y0 = 0.5;                           // Value of the convolution at the inflection point.\n  mediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * sigma);  // Slope of the convolution at the inflection point.\n  mediump float d = (y - y0) / m0;                        // Inversion of a local linearization.\n\n  // Return the estimated distance.\n  return d;\n}\n\n// Shading based on estimated distance.\nmediump vec4 shade(mediump float d) {\n  // Maps the sampled distance from the [A, D] range (see HighlightRenderer::setHighlightOptions) to [0, 1].\n  mediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\n\n  // Force to [0, 1]; it should not be necessary because the shade texture uses the CLAMP address mode, so\n  // this should happen anyway internally to the sampler, but in practice it is needed to avoid weird\n  // banding artifacts.\n  // We don't really know if we need this or not.\n  mappedDistance = clamp(mappedDistance, 0.0, 1.0);\n\n  // Sample the 1-D shade texture on its center line (i.e. on t=0.5).\n  return texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\n\nvoid main(void) {\n  // Estimate the distance.\n  mediump float d = estimateDistance();\n\n  // Shade the distance.\n  gl_FragColor = shade(d);\n}\n","textured.vert":"// Identity vertex shader that outputs an untransformed 2-D vertex\n// and passes its texture coordinates unchanged to the interpolator.\n\n// Vertex position.\nattribute mediump vec2 a_position;\n\n// Texture coordinates.\nattribute mediump vec2 a_texcoord;\n\n// Texture coordinates to be interpolated.\nvarying mediump vec2 v_texcoord;\n\nvoid main(void) {\n  // Pass the position unchanged.\n  gl_Position = vec4(a_position, 0.0, 1.0);\n\n  // Pass the texture coordinates unchanged.\n  v_texcoord = a_texcoord;\n}\n"},materials:{fill:{"fill.frag":"precision lowp float;\nuniform lowp float u_opacity;\n\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\nvoid main()\n{\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = u_opacity * v_opacity * v_color * color;\n#else\n  gl_FragColor = u_opacity * v_opacity * v_color;\n#endif // PATTERN\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  //if (gl_FragColor.a < 1.0 / 255.0) {\n  //  discard;\n  //}\n  gl_FragColor = v_id;\n#endif // ID\n}\n","fill.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_id; // since we need to render the Id as a color we need to break it into RGBA components. so just like a color, the Id is normalized.\nattribute vec4 a_color;\nattribute vec4 a_tlbr;\nattribute vec4 a_aux;\n\nattribute float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\nuniform highp mat4 u_transformMatrix;\nuniform highp vec2 u_normalized_origin;\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/fill/vvUniforms.glsl>\n#include <materials/fill/vvFunctions.glsl>\n\n#ifdef PATTERN\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n#ifdef VV_OPACITY\n  v_opacity = getVVOpacity(a_vv.y);\n#else\n  v_opacity = 1.0;\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.x, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n\n#ifdef PATTERN\n  // calculate the pattern matrix\n  mat3 patternMatrix = mat3(1.0, 0.0, 0.0,\n                            0.0, 1.0, 0.0,\n                            0.0, 0.0, 1.0);\n  patternMatrix[0][0] = 1.0 / (u_zoomFactor * a_aux.x);\n  patternMatrix[1][1] = 1.0 / (u_zoomFactor * a_aux.y);\n\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from\n  // tile coordinates to texture coordinates.\n  v_tileTextureCoord = (patternMatrix * vec3(a_pos, 1.0)).xy;\n  v_tlbr = vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\n#endif // PATTERN\n\n  float z = 2.0 * (1.0 - a_visible); // clip the vertex if the geometry isn't visible\n  gl_Position = vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(a_pos, z, 1.0);\n}\n","vvFunctions.glsl":"bool isNan(float val) {\n  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\n\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR)|| defined(VV_OPACITY)\nattribute vec4 a_vv;\n#endif // VV_COLOR || VV_OPACITY\n\n#ifdef VV_COLOR\nuniform float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_OPACITY\nuniform float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n"},icon:{"icon.frag":"precision mediump float;\n\nuniform lowp sampler2D u_texture;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n#ifdef HEATMAP\nvarying mediump float v_heatmapWeight;\n#endif // HEATMAP\n\nconst float softEdgeRatio = 1.0; // use blur here if needed\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  float size = max(v_size.x, v_size.y);\n  float dist = d * size * softEdgeRatio;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (v_outlineWidth > 0.25) {\n    lowp vec4 outlinePixelColor = v_outlineColor;\n\n    // outlines can't be larger than the size of the symbol\n    float clampedOutlineSize = min(v_outlineWidth, size);\n\n    outlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\n\n    // finally combine the outline and the fill colors (outline draws on top of fill)\n    gl_FragColor = v_transparency * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n  lowp vec4 texColor = texture2D(u_texture, v_tex);\n\n#ifdef HEATMAP\n  texColor.r *= v_heatmapWeight;\n#endif // HEATMAP\n\n  gl_FragColor = v_transparency * texColor;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"precision mediump float;\n\n//const float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst vec2 SIGNED_BYTE_TO_UNSIGNED = vec2(128.0);\n\n// per quad (instance) attributes (20 bytes ==> equivalent of 5 bytes per vertex)\nattribute vec2 a_pos;\nattribute vec4 a_vertexOffsetAndTex;\nattribute vec4 a_id; // since we need to render the Id as a color we need to break it into RGBA components. so just like a color, the Id is normalized.\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\n\nattribute float a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_opacity;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n// the of the icon given in pixels\nvarying mediump vec2 v_size;\n\n// icon color. If is a picture-marker it is used to tint the texture color\nvarying lowp vec4 v_color;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n#ifdef HEATMAP\nattribute float a_heatmapWeight;\nvarying mediump float v_heatmapWeight;\n#endif // HEATMAP\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/icon/vvUniforms.glsl>\n#include <materials/icon/vvFunctions.glsl>\n\nvoid main()\n{\n  vec2 a_offset = a_vertexOffsetAndTex.xy;\n  vec2 a_tex = a_vertexOffsetAndTex.zw + SIGNED_BYTE_TO_UNSIGNED; // offset to change from signed to unsigned byte\n  vec2 a_size = a_sizeAndOutlineWidth.xy;\n\n  // default values (we need them for the variations to come)\n  float a_angle = 0.0;\n  float delta_z = 2.0 * (1.0 - a_visible);\n  float depth = 0.0;\n  v_transparency = 1.0;\n\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  // vv size override the original symbol's size\n  float h = getVVMinMaxSize(a_vv.x, a_size.y);\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\n  float h = u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\n  float h = getVVStopsSize(a_vv.x, a_size.y);\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\n  float h = getVVUnitValue(a_vv.x, a_size.y);\n#endif // VV_SIZE_UNIT_VALUE\n\n  // make sure to preserve the aspect ratio of the symbol\n  vec2 size = vec2(h * a_size.x / a_size.y, h);\n  vec2 offset = a_offset * size / a_size;\n  v_size = size;\n#else\n#ifdef HEATMAP\n  // reconstruct the kernel size\n  a_size = 9.0 * a_size + 1.0;\n#endif // HEATMAP\n\n  vec2 offset = a_offset;\n  v_size = a_size;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef SDF\n  offset *= 2.0;\n#endif // SDF\n\n#ifdef VV_ROTATION\n  gl_Position = vec4(u_normalized_origin, depth, 0.0) + u_transformMatrix * vec4(a_pos, delta_z, 1.0) + u_extrudeMatrix * getVVRotation(a_vv.w) * vec4(offset, 0.0, 0.0);\n#else\n  gl_Position = vec4(u_normalized_origin, depth, 0.0) + u_transformMatrix * vec4(a_pos, delta_z, 1.0) + u_extrudeMatrix * vec4(offset, 0.0, 0.0);\n#endif // VV_ROTATION\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#else\n  v_transparency = u_opacity;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n  // output the texture coordinates and the transparency\n  v_tex = a_tex / u_mosaicSize;\n\n#ifdef SDF\n  v_outlineColor = a_outlineColor;\n  v_outlineWidth = a_sizeAndOutlineWidth.z;\n#endif // SDF\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n\n#ifdef HEATMAP\n  v_heatmapWeight = a_heatmapWeight;\n#endif // HEATMAP\n}\n","vvFunctions.glsl":"bool isNan(float val) {\n  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  interpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\n  return u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\nattribute vec4 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\n\n#ifdef VV_COLOR\nuniform float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n"},label:{"label.frag":"precision lowp float;\n\nuniform mediump sampler2D u_referenceTex;\nuniform mediump vec2 u_screenSize;\nuniform mediump float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying mediump float v_fadeStep;\n#else\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_color;\n#endif // ID\n\nconst vec3 epsilon = vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\nvoid main()\n{\n  mediump vec2 refTextPos = gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\n  mediump vec4 referenceFragment = texture2D(u_referenceTex, refTextPos);\n#ifdef ID\n  mediump float alpha = clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\n  // fill the whole quad\n  gl_FragColor = vec4(alpha);\n#else\n  // read the fade alpha\n  lowp float fadeAlpha = referenceFragment.a;\n\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  float glyphEdgeDistance = 0.75 - v_edgeDistanceOffset;\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float sdfAlpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n  gl_FragColor = fadeAlpha * sdfAlpha * v_transparency * v_color;\n#endif\n}\n",
"label.vert":"precision mediump float;\n\nattribute vec2 a_pos;                  // 2 * 2 (2 x signed 16)\nattribute vec4 a_color;                // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset;         // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texAndSize;          // 4 (4 x unsigned byte) texture coordinatesm and font size. w is for the halo size\nattribute vec4 a_refSymbolAndPlacementOffset; // 4 (4 x unsigned byte) the offset of the reference symbol of the feature (x,y) and the placement offset (z, w) all given in pixels\n\nattribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\nattribute mediump vec2 a_visibilityRange; // 2 x unsigned byte;\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\n// the opacity of the layer\nuniform mediump float u_opacity;\n\n// the curent zoom\nuniform mediump float u_zoomLevel; // the current zoom level X 10\nuniform lowp float u_mapRotation;\nuniform lowp float u_mapAligned;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\n#ifdef ID\nuniform mediump float u_fadeStep;\nvarying mediump float v_fadeStep;\n#else\nvarying mediump vec4 v_color;\n#endif // ID\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\n// by 16 and then at the shader devide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\nconst float outlineScale = 1.0 / 10.0;\nconst float sdfFontSize = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\n// 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\nconst float maxSdfDistance = 8.0;\n\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\n\nvoid main()\n{\n  // make sure to clip the vertices in case that given record is marked as invisible\n  float z = 2.0 * (1.0 - a_visible);\n\n  // clip the vertex if we are beyond the visibility range of the vertex\n  // please note: min value of 0 is regarded infinity. max value of 255 is regarded infinity\n  z += 1.0 + sign(a_visibilityRange.x - u_zoomLevel);\n  z += 1.0 + sign(u_zoomLevel - a_visibilityRange.y);\n\n  // we use the list significant bit of the position in order to store the indication whethe the vertex is of a halow of a glyph\n  mediump float halo = mod(a_pos, 2.0).x;\n\n  float fontSize = a_texAndSize.z;\n\n  float fontScale = fontSize / sdfFontSize;\n  // we need to scale the extrude matrix by the font-scale in order to get the right text size\n  mat4 extrudeMatrix = fontScale * u_extrudeMatrix;\n\n  float mapRotation = u_mapAligned * C_DEG_TO_RAD * -u_mapRotation;\n  float sinA = sin(mapRotation);\n  float cosA = cos(mapRotation);\n\n  mat4 mapRotationMat = mat4(cosA, sinA, 0.0, 0.0,\n                            -sinA, cosA, 0.0, 0.0,\n                              0.0,  0.0, 1.0, 0.0,\n                              0.0,  0.0, 0.0, 1.0);\n\n  vec4 refSymbolOffset = mapRotationMat *  vec4(a_refSymbolAndPlacementOffset.xy, 0.0, 0.0);\n\n  gl_Position = vec4(u_normalized_origin, 0.0, 0.0) +\n                u_transformMatrix * vec4(floor(a_pos * 0.5), z, 1.0) +\n                u_extrudeMatrix * vec4(refSymbolOffset.xy + a_refSymbolAndPlacementOffset.zw, 0.0, 0.0) +\n                extrudeMatrix * vec4(offsetPrecision * a_vertexOffset, 0.0, 0.0);\n\n  v_tex = a_texAndSize.xy / u_mosaicSize;\n  v_antialiasingWidth = 0.106 * sdfFontSize / fontSize / u_pixelRatio;\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = halo * outlineScale * a_texAndSize.w / fontScale / maxSdfDistance;\n\n  v_transparency = u_opacity;\n\n#ifdef ID\n  v_fadeStep = u_fadeStep;\n#else\n  v_color = a_color;\n#endif // ID\n}\n"},line:{"constants.glsl":"const float thinLineHalfWidth = 1.0; // meaning that a 2 pixels line width is considered a thin line\nconst float thinLineWidthFactor = 1.1;\n","line.frag":"precision lowp float;\n\nuniform lowp float u_blur;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\nuniform mediump float u_zoomFactor;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef SDF\nconst float sdfPatternHalfWidth = 15.5; // YF: assumed that the width will be set to 31\nconst float widthFactor = 2.0;\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\n#include <materials/line/constants.glsl>\n\nvoid main()\n{\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n  mediump float thinLineFactor = max(thinLineWidthFactor * step(v_lineHalfWidth, thinLineHalfWidth), 1.0);\n\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // when it is a thin line then use a slightly shallower slope in order to add more feathering\n  lowp float alpha = clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\n\n#if defined(SDF)\n  mediump float lineHalfWidth = widthFactor * v_lineHalfWidth;\n  mediump float lineWidthRatio = lineHalfWidth / sdfPatternHalfWidth;\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\n  mediump float relativeTexY = 0.5 + 0.5 * v_normal.y;\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  mediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\n\n  // the distance is a proportional to the line width\n  float dist = d * lineHalfWidth;\n\n  lowp vec4 fillPixelColor = v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n  gl_FragColor = fillPixelColor;\n#elif defined(PATTERN)\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\n\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  gl_FragColor = v_transparency * alpha * v_color * color;\n#else // solid line (no texture, no pattern)\n  // output the fragment color\n  gl_FragColor = v_transparency * alpha * v_color;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\n\nattribute float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\nuniform lowp float u_opacity; // the layer's opacity\nuniform mediump float u_zoomFactor;\nuniform mediump float u_antialiasing;\n\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\nconst float scale = 1.0 / 31.0;\n#ifdef SDF\nconst float widthFactor = 2.0;\n#else\nconst float widthFactor = 1.0;\n#endif\n\n\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\n#endif // PATTERN\n\n// we need to accumulated distance only if it is a pattern or an SDF line\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/line/vvUniforms.glsl>\n#include <materials/line/vvFunctions.glsl>\n\n// include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\n#include <materials/line/constants.glsl>\n\nvoid main()\n{\n// size VV block\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  mediump float lineHalfWidth = 0.5 * getVVMinMaxSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\n  mediump float lineHalfWidth = 0.5 * u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\n  mediump float lineHalfWidth = 0.5 * getVVStopsSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\n  mediump float lineHalfWidth = 0.5 * getVVUnitValue(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_UNIT_VALUE\n\n#else // no VV\n  mediump float lineHalfWidth = a_accumulatedDistanceAndHalfWidth.y * scale;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_OPACITY\nv_transparency = u_opacity * getVVOpacity(a_vv.z);\n#else\nv_transparency = u_opacity;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nv_color = getVVColor(a_vv.y, a_color);\n#else\nv_color = a_color;\n#endif // VV_COLOR\n\n  // make sure to clip the vertices in case that the width of the line is 0 (or negative), or in case that the line is not visible\n  float z = 2.0 * (step(lineHalfWidth, 0.0) + (1.0 - a_visible));\n\n  // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\n  // also limit the total line width to 1.3 pixels. Below this value lines don't look good compared to the SVG renderer\n  lineHalfWidth = max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\n\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n  // in practice, a thin line is a line who's half width vary from 0.45px to the value of thinLineHalfWidth, as the value\n  // is claped in line 221 above\n  mediump float thinLineFactor = max(thinLineWidthFactor * step(lineHalfWidth, thinLineHalfWidth), 1.0);\n\n  v_lineHalfWidth = lineHalfWidth;\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ [0, 1])\n  // in a case of a thin line we move each vertex twice as far\n  mediump vec2 dist = thinLineFactor * widthFactor * lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n  // transform the vertex\n  gl_Position = vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(a_pos, z, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#if defined(PATTERN) || defined(SDF)\n  v_accumulatedDistance = a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\n#endif // PATTERN || SDF\n\n#ifdef PATTERN\nv_tlbr = vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\nv_patternSize = vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\n#endif // PATTERN\n\n#ifdef ID\nv_id = a_id;\n#endif // ID\n}\n","vvFunctions.glsl":"bool isNan(float val) {\n  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  float f = (sizeValue - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  return clamp(mix(u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w, f), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY)\nattribute vec3 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY\n\n#ifdef VV_COLOR\nuniform float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform float u_vvSizeScaleStopsValue;\n#endif\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n"},text:{"text.frag":"precision lowp float;\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  float glyphEdgeDistance = 0.75 - v_edgeDistanceOffset;\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float alpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"precision mediump float;\n\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\n\nattribute vec2 a_pos;           // 2 * 2 (2 x signed 16)\nattribute vec4 a_id;            // 4 (4 x unsigned byte)\nattribute vec4 a_color;         // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texFontSize; // 4 (4 x unsigned byte) texture coordinatesm and font size\n\nattribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\n// the opacity of the layer\nuniform mediump float u_opacity;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\n// by 16 and then at the shader devide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\nconst float outlineScale = 1.0 / 10.0;\nconst float sdfFontSize = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\n// 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\nconst float maxSdfDistance = 8.0;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/text/vvUniforms.glsl>\n#include <materials/text/vvFunctions.glsl>\n\nvoid main()\n{\n  // make sure to clip the vertices in case that given record is marked as invisible\n  float z = 2.0 * (1.0 - a_visible);\n\n  // we use the list significant bit of the position in order to store the indication whethe the vertex is of a halow of a glyph\n  mediump float halo = mod(a_pos, 2.0).x;\n\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  // vv size override the original symbol's size\n  vec2 size = vec2(getVVMinMaxSize(a_vv.x, a_texFontSize.z));\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\n  vec2 size = vec2(u_vvSizeScaleStopsValue);\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\n  vec2 size = vec2(getVVStopsSize(a_vv.x, a_texFontSize.z));\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\n  vec2 size = vec2(getVVUnitValue(a_vv.x, a_texFontSize.z));\n#endif // VV_SIZE_UNIT_VALUE\n\n  float fontSize = size.x;\n#else // this generic case, no VV\n  float fontSize = a_texFontSize.z;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  float fontScale = fontSize / sdfFontSize;\n  // we need to scale the extrude matrix by the font-scale in order to get the right text size\n  mat4 extrudeMatrix = fontScale * u_extrudeMatrix;\n\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\n  //gl_Position = vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(floor(a_pos * 0.5), z, 1.0) + extrudeMatrix * vec4(offsetPrecision * a_vertexOffset, 0.0, 0.0);\n\n#ifdef VV_ROTATION\n  gl_Position = vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(floor(a_pos * 0.5), z, 1.0) + extrudeMatrix * getVVRotation(a_vv.w) * vec4(offsetPrecision * a_vertexOffset, 0.0, 0.0);\n#else\n  gl_Position = vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(floor(a_pos * 0.5), z, 1.0) + extrudeMatrix * vec4(offsetPrecision * a_vertexOffset, 0.0, 0.0);\n#endif // VV_ROTATION\n\n  v_tex = a_texFontSize.xy / u_mosaicSize;\n  v_antialiasingWidth = 0.105 * sdfFontSize / fontSize / u_pixelRatio;\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = halo * outlineScale * a_texFontSize.w / fontScale / maxSdfDistance;\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#else\n  v_transparency = u_opacity;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\n  // we don't want to override the halo color\n  v_color = halo * a_color + (1.0 - halo) * getVVColor(a_vv.y, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n}\n","vvFunctions.glsl":"bool isNan(float val) {\n  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  return clamp(u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\nattribute vec4 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\n\n#ifdef VV_COLOR\nuniform float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n"}},stencil:{"stencil.frag":"void main() {\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n","stencil.vert":"attribute vec2 a_pos;\n\nvoid main() {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat4 u_transformMatrix;\nuniform mediump vec2 u_normalized_origin;\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offests = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(offests, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}});